@using CIAT.DAPA.USAID.Forecast.Web.Models.Tools;
@using Microsoft.AspNetCore.Builder
@using Microsoft.AspNetCore.Localization
@using Microsoft.Extensions.Options

@inject IOptions<RequestLocalizationOptions> LocOptions
@inject Microsoft.Extensions.Options.IOptions<Settings> AppSettings


@{
    ViewData["Title"] = "Report";
}

<!-- Add a download button -->

<div class="report-wrapper">
    <div class="report-content">

        <a onclick="savePdf()" class="btn btn-primary print-button">@Localizer["download-pdf"]</a>

        <small class="meta-info">

            <span> @ViewBag.weatherStation.State, @ViewBag.weatherStation.Municipality</span>
            <span> @DateTime.Now.ToString("yyyy-MM-dd")</span>

        </small>
        <h2>@Localizer["report", @ViewBag.weatherStation.Name]</h2>

        <p>
            @Localizer["provided-by", @ViewBag.weatherStation.Origin]
        </p>

        <div id="reportMap">
        </div>
        <small class="meta-info">
            @Localizer["coordinates", @ViewBag.weatherStation.Latitude, @ViewBag.weatherStation.Longitude]
        </small>

        <h3>@Localizer["weather"]</h3>

        <div id="precipitationChart">

        </div>

        <!--h4>@Localizer["climate-scenarios"]</h4-->
        <div id="scenarioCharts" class="scenario-charts">

        </div>


        <h3>@Localizer["crops"]</h3>

        <div id="yieldContainers">
        </div>

    </div>
</div>



@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <link rel="stylesheet" href="~/css/maps.css" />

    <style>

       
       
        @@media print {
            body {
                margin: 0;
                min-width: 210mm !important;
            }
            .yield-label{
                border: 4px solid;
            }
            .yield-low {
                border-color: #e33327;
            }

            .yield-regular {
                border-color: #e37f27;
            }

            .yield-normal {
                border-color: #c7e327;
            }

            .yield-good {
                border-color: #82e327;
            }

            .yield-excellent {
                border-color: #15eb31;
            }

            .print-button {
               display:none;
            }

        }

      
        .meta-info {
            color: grey;
        }
        .printable-chart{
         
            margin:auto;
        }

        .print-button {
            position: absolute;
            right: 1em;
            top: -17px;
        }

        #reportMap {
            height: 256px;
            width: 100%;
        }
        #precipitationChart {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-around;
        }
        .precipitation-chart {
            width:100%;
            position: relative;
            max-width: 5000px;
        }
        .precipitation-container{
            max-width: 300px;
        }

        .report-wrapper {
            background: white;
            padding: 1em;
            position: relative;
            max-width: 250mm;
            margin: auto;
        }


        .report-content {
            max-width: 210mm;
            margin: auto;
        }

        .scenario-charts {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            column-gap: 10px;
            row-gap: 1em;
        }
        .scenario-table{
            width:100%;
        }

        .scenario-chart {
            display: block;
            break-inside: avoid;
            page-break-inside: avoid;
            padding: 4px;
        }

        .yield-table {
            margin-top: 1em;
            width: 100%;
            border-collapse: separate;
            /* This ensures that border-spacing is applied */
            border-spacing: 6px;
            /* Adjust the value to set the desired gap size */
        }

        .yield-table td {
            padding: 4px;
        }
        .yield-chart{
            width:100%;
            position:relative;
        }

        .border-row {
            background: grey;
            height: 1px;
        }

        .border-row td {
            padding: 0 !important;
        }
        
        .yield-table td:nth-child(1) {
            width: 200px;
        }

        .yield-table td:nth-child(2) {
            width: 200px;
        }

        .yield-table td:nth-last-child(-n+3) {

            width: 200px;
        }

        .yield-label {
            padding: 8px 8px 8px 8px !important;
            border-radius: 1em;
            display: flex;
            align-items: center;
            justify-content: start;
            gap: 4px;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.6);
            white-space: pre;
         
        }

        .yield-icon {
            font-size: 22px;
        }

        .crop-labels {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 4px;
            margin: auto;
            max-width: 1000px;
        }

       

        .yield-low {
            background: #e33327;
        }

        .yield-regular {
            background: #e37f27;
        }

        .yield-normal {
            background: #c7e327;
        }

        .yield-good {
            background: #82e327;
        }

        .yield-excellent {
            background: #15eb31;
        }
    </style>

    <script type="text/javascript">


        var weatherStation = @Html.Raw(Json.Serialize(ViewBag.weatherStation));
        var weatherForecast = @Html.Raw(Json.Serialize(ViewBag.weatherForecast));





        var historicalWeatherData = @Html.Raw(Json.Serialize(ViewBag.historicalWeatherData));

        var agronomics = @Html.Raw(Json.Serialize(ViewBag.agronomics));
        var yieldForecast = @Html.Raw(Json.Serialize(ViewBag.yieldForecast));

        console.log('weatherStation', weatherStation);
        console.log('weatherForecast', weatherForecast);

        console.log('historicalWeatherData', historicalWeatherData);


        console.log('agronomics', agronomics);
        console.log('yieldForecast', yieldForecast);


        createMap();
        if (weatherForecast.climate?.length > 0) {
            createForecastCharts(weatherForecast.climate[0], weatherStation);
        }


        if (weatherForecast.scenario?.length > 0) {
          //  createForecastScenarioCharts(weatherForecast.scenario, historicalWeatherData);
        }

        createYieldTable(agronomics, yieldForecast);
        createYieldDiagrams(agronomics, yieldForecast)

        function createMap() {

            return new Promise((resolve, reject) => {

                let mapContainer = document.getElementById('reportMap');
                var map = L.map(mapContainer, { zoomControl: false }).setView([weatherStation.latitude, weatherStation.longitude], 8);
                map.dragging.disable();
                map.touchZoom.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
                map.boxZoom.disable();
                map.keyboard.disable();
                if (map.tap) map.tap.disable();
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                    subdomains: ['a', 'b', 'c']
                }).addTo(map);
                L.marker([weatherStation.latitude, weatherStation.longitude]).addTo(map);
                map.invalidateSize();

            });
        }

        function createForecastCharts(forecastClimate, weatherStation) {



            var options = {
                series: [{
                    name: '@Localizer["forecast-lower"]',
                    data: forecastClimate.data.map(d => d.probabilities.find(prob => prob.measure == 'prec').lower)
                }, {
                    name: '@Localizer["forecast-normal"]',
                    data: forecastClimate.data.map(d => d.probabilities.find(prob => prob.measure == 'prec').normal)
                }, {
                    name: '@Localizer["forecast-upper"]',
                    data: forecastClimate.data.map(d => d.probabilities.find(prob => prob.measure == 'prec').upper)
                }],
                chart: {
                    type: 'bar',
                    height: 180,
                    stacked: true,
                    stackType: '100%',
                    toolbar: {
                        show: false
                    },
                    zoom: {
                        enabled: false,
                    },
                    redrawOnWindowResize: true,
                    redrawOnParentResize: true,

                },
                plotOptions: {
                    bar: {
                        horizontal: true,
                    },
                },
                stroke: {
                    width: 1,
                    colors: ['#fff']
                },
                title: {
                    text: 'Probability for precipitation'
                },
                grid: {
                    show: false,
                },
                xaxis: {
                    axisBorder: {
                        show: false,
                    },
                    labels: {
                        show: false,
                    },
                    axisTicks: {
                        show: false,
                    },
                    categories: forecastClimate.data.map(val => {
                        let trimester = [(val.month - 1) % 12, (val.month) % 12, (val.month + 1) % 12]
                        let monthStrings = trimester.map(m => new Date(val.year, m - 1).toLocaleString('default', { month: 'short' })).join(' - ');
                        return val.year + ': '+ monthStrings;
                    }),

                },
                yaxis: {
                    labels: {
                        maxWidth: 300,
                        style: {
                            fontWeight: 700,
                        },
                    }
                },
                tooltip: {
                    y: {
                        formatter: function (val) {
                            return Math.round(val * 100) + '%'
                        }
                    }
                },
                fill: {
                    opacity: 1

                },
                colors: ['#99d3ff', '#0390fc', '#005696'],
                legend: {
                    position: 'bottom',
                    horizontalAlign: 'center',
                }
            };
            var element = document.createElement('div');
            element.classList.add('precipitation-chart');
            element.classList.add('printable-chart');

            document.querySelector("#precipitationChart").before(element)
            var chart = new ApexCharts(element, options);
            chart.render();



          //  console.log(forecastClimate)

            forecastClimate.data.forEach(val => {


                var donutEl = document.createElement('div');
                donutEl.classList.add('precipitation-container')
                document.querySelector("#precipitationChart").appendChild(donutEl)



                let trimester = [(val.month - 1) % 12, (val.month) % 12, (val.month + 1) % 12]
                let monthStrings = trimester.map(m => new Date(val.year, m - 1).toLocaleString('default', { month: 'short' })).join(' - ');
                let title = monthStrings + ' (' + val.year+')';


                var options = {
                    series: [
                        val.probabilities.find(prob => prob.measure == 'prec').lower,
                        val.probabilities.find(prob => prob.measure == 'prec').normal,
                        val.probabilities.find(prob => prob.measure == 'prec').upper,

                    ],
                    labels: ['@Localizer["forecast-lower"]', '@Localizer["forecast-normal"]', '@Localizer["forecast-upper"]'],
                    colors: ['#99d3ff', '#0390fc', '#005696'],
                    chart: {
                        type: 'donut',
                        height: 280,
                    },
                    title: {
                        align: 'center',
                        text: title,
                    },
                    subtitle: {
                        text: 'Probability for precipitation',
                        align: 'center',

                    },

                    plotOptions: {
                        pie: {
                            donut: {
                                size: '33%'
                            }
                        }
                    },
                    legend: {
                        position: 'bottom',
                        horizontalAlign: 'center',

                    },
                    tooltip: {
                        y: {
                            formatter: function (val) {
                                return Math.round(val * 100) + '%'
                            }
                        }
                    },

                };
                var element = document.createElement('div');
                donutEl.appendChild(element)
                var chart = new ApexCharts(element, options);
                chart.render();




                var result =  '@Localizer["forecast-normal"]';

                var prec = val.probabilities.find(prob => prob.measure == 'prec');
                if (prec.lower >= prec.normal && prec.lower >= prec.upper) { result ='@Localizer["forecast-lower"]'; }
                else if (prec.upper >= prec.normal && prec.upper >= prec.lower) { result = '@Localizer["forecast-upper"]'; }



                var descriptionEl = document.createElement('div');
                descriptionEl.innerHTML = '@Localizer["forecast-time"]'
                    + " <strong>" + monthStrings+"</strong> "
                    + '@Localizer["forecast-location"]'
                    + " <strong>" + weatherStation.municipality + "</strong> "
                    + '@Localizer["forecast-result"]'
                    + " <strong>" + result + "</strong>.";
                donutEl.appendChild(descriptionEl)
            });






        }


        function createForecastScenarioCharts(forecastScenarios, historicalWeatherData) {


            let paramLists = [
                {
                    id: 'prec',
                    label: '@Localizer["precipitation-w-unit"]',
                    color: '#33b2df',
                },
                {
                    id: 'sol_rad',
                    label: '@Localizer["solar-w-unit"]',
                    color: '#e427f5',
                },
                {
                    id: 't_max',
                    label:  '@Localizer["max-temp-w-unit"]',
                    color: '#f54227',
                },
                {
                    id: 't_min',
                    label: '@Localizer["min-temp-w-unit"]',
                    color: '#ff7e6b',
                },
            ]


            paramLists.forEach(param => {


                let data = []
                forecastScenarios.filter(sc => sc.name == 'avg').sort((a, b) => a.year - b.year).forEach(yearlyData => {
                    yearlyData.monthly_Data.forEach(monthlyData => {

                        data.push({
                            month: new Date(yearlyData.year, monthlyData.month - 1).toLocaleString('default', { month: 'short' }),
                            avg: monthlyData.data.find(d => d.measure == param.id).value,
                            min: forecastScenarios.find(sc => sc.name == 'min' && sc.year == yearlyData.year).monthly_Data.find(d => d.month == monthlyData.month).data.find(d => d.measure == param.id).value,
                            max: forecastScenarios.find(sc => sc.name == 'max' && sc.year == yearlyData.year).monthly_Data.find(d => d.month == monthlyData.month).data.find(d => d.measure == param.id).value,
                            historical: historicalWeatherData?.monthly_Data.find(_md => _md.month == monthlyData.month)?.data.find(d => d.measure == param.id)?.value
                        })

                    })
                })




                var minY = Math.min.apply(null, data.map(d => (d.min)));
                var options = {
                    series: [

                        {
                            type: 'line',
                            name: 'Forecast',
                            data: data.map(d => {
                                return {
                                    x: d.month,
                                    y: Math.round(d.avg)
                                }
                            })

                        },
                          {
                            type: 'line',
                            name: 'Historical average',
                            data: data.map(d => {
                                return {
                                    x: d.month,
                                    y: Math.round(d.historical)
                                }
                            })

                        },
                      {
                            type: 'rangeArea',
                            name: 'Forecast Range (min-max)',
                            data: data.map(d => {
                                return {
                                    x: d.month,
                                    y: [Math.round(d.min), Math.round(d.max)]
                                }
                            })
                        },
                    ],



                    chart: {
                        height: 250,
                        type: 'rangeArea',
                        animations: {
                            speed: 500
                        },
                        redrawOnParentResize: true,
                        toolbar: {
                            show: false
                        },
                        zoom: {
                            enabled: false,
                        }
                    },
                    yaxis: {
                        min: minY - 3 < 0 ? 0 : minY-3,
                    },

                    colors: [param.color,'#7a7a7a', param.color],
                    dataLabels: {
                        enabled: false
                    },

                    fill: {
                        opacity: [1, 1, 0.2]
                    },

                    stroke: {
                        curve: 'smooth',
                        width: [2, 2, 0,],
                        dashArray: [0, 8, 0]
                    },
                    legend: {
                        show: true,
                        //  customLegendItems: ['Forecast','Historical average','Range'],
                        //    inverseOrder: true
                    },
                    title: {
                        text: param.label
                    },
                    markers: {
                        hover: {
                            sizeOffset: 5
                        }
                    }
                };

                let element = document.createElement('div');
                element.classList.add('scenario-chart')
                document.querySelector("#scenarioCharts").appendChild(element)
                let chart = new ApexCharts(element, options);
                chart.render();

            })


            let table = document.createElement('table');
            table.classList.add('scenario-table')
           // console.log(document.querySelector("#scenarioCharts"))
            document.querySelector("#scenarioCharts").after(table);

            let header = document.createElement('tr');
            table.appendChild(header);
            let td = document.createElement('th');
            td.innerHTML = "-"
            header.appendChild(td);

            forecastScenarios.filter(sc => sc.name == 'avg').sort((a, b) => a.year - b.year).forEach(yearlyData => {
                yearlyData.monthly_Data.forEach(monthlyData => {

                    const date = new Date(yearlyData.year, monthlyData.month - 1);

                    let td = document.createElement('th');
                    td.innerHTML = date.toLocaleDateString("default", { year: 'numeric', month: 'long' });
                    header.appendChild(td);
                })


            })


            paramLists.forEach(param => {
                let row = document.createElement('tr');
                table.appendChild(row);

                let cat = document.createElement('td');
                cat.innerHTML = param.label;
                row.appendChild(cat);

                forecastScenarios.filter(sc => sc.name == 'avg').sort((a, b) => a.year - b.year).forEach(yearlyData => {
                    yearlyData.monthly_Data.forEach(monthlyData => {


                        let avg = Math.round (monthlyData.data.find(d => d.measure == param.id).value);
                        let historical = Math.round(historicalWeatherData?.monthly_Data.find(_md => _md.month == monthlyData.month)?.data.find(d => d.measure == param.id)?.value)

                        let val = document.createElement('td');
                        val.innerHTML = avg + " <span class='meta-info'>(" + historical +")</span>";
                        row.appendChild(val);


                    })
                })


            })








        }


        function createYieldTable(agronomics, yieldForecast) {


            let sortedCrops = agronomics.sort((a, b) => {
                if (a.cp_Name < b.cp_Name) {
                    return -1;
                }
                if (a.cp_Name > b.cp_Name) {
                    return 1;
                }
                return 0;
            })


            sortedCrops.forEach(crop => {

                var cropRanges = weatherStation.ranges.filter(r => r.crop_Id == crop.cp_Id);
                cropRanges.sort((a, b) => a.lower - b.lower)
               // console.log('cropRanges', cropRanges)


                var cropHeader = document.createElement('h3');
                cropHeader.classList.add('crop-heading')
                cropHeader.innerHTML = crop.cp_Name;


                var cropLabels = document.createElement('div');
                cropLabels.classList.add('crop-labels')
                cropRanges.forEach((r, i) => {

                    let cropLabel = createYieldIndicatorLabel(i, '<strong>'+ r.label + '</strong>\n' + roundToTons(r.lower) + ' - ' + roundToTons(r.upper) + 't/ha');
                    cropLabels.appendChild(cropLabel)
                })


                var table = document.createElement('table');
                table.classList.add('yield-table')

                var header = document.createElement('tr');
                table.appendChild(header)
                var col1 = document.createElement('th');
                col1.innerHTML = '@Localizer["cultivar"]'
                header.appendChild(col1)

                var col2 = document.createElement('th');
                col2.innerHTML = '@Localizer["soil"]'
                header.appendChild(col2)

                var col3 = document.createElement('th');
                col3.innerHTML ='@Localizer["worst-date"]'
                header.appendChild(col3)


                var col4 = document.createElement('th');
                col4.innerHTML = '@Localizer["best-date"]'
                header.appendChild(col4)

                var col5 = document.createElement('th');
                col5.innerHTML = '@Localizer["comment"]'
                header.appendChild(col5)



                var results = 0;
                crop.cultivars.forEach((cultivar) => {
                    let i = 0;
                    crop.soils.forEach((soil) => {
                        if (yieldForecast.yield.length == 0) return;

                        let yields = yieldForecast.yield[0].yield.filter(yieldData => yieldData.cultivar == cultivar.id && yieldData.soil == soil.id)
                        if (yields?.length > 0) {

                            yields = [...yields].sort((a, b) => extractYield(a) - extractYield(b));
                            //   console.log('cultivar', cultivar)
                            //   console.log('soil', soil)
                            //   console.log('sorted', yields)

                            let min = yields[0];
                            let max = yields[yields.length - 1];
                            let median = yields[Math.floor(yields.length / 2)]; //since we work with objects, a true median is not possible for uneven array lengths, therefore aproximation

                            // console.log('min', min)
                            //  console.log('max', max)
                            //  console.log('median', median)



                            var row = document.createElement('tr');
                            if (i == 0) {
                                var seperator = document.createElement('tr');
                                seperator.innerHTML = '<td colspan="5"></td>'
                                seperator.classList.add('border-row')
                                table.appendChild(seperator)

                                var colCultivar = document.createElement('td');
                                let soilTypes = yieldForecast.yield[0].yield.filter(yieldData => yieldData.cultivar == cultivar.id).map(yieldData => yieldData.soil)
                                let distinctSoils = [... new Set(soilTypes)]

                                colCultivar.setAttribute('rowspan', distinctSoils.length)
                                colCultivar.innerHTML = cultivar.name;
                                row.appendChild(colCultivar)
                            }

                            var colSoil = document.createElement('td');
                            colSoil.innerHTML = soil.name;
                            row.appendChild(colSoil)


                            var colMin = document.createElement('td');
                            let minYield = findYieldCass(extractYield(min), cropRanges);
                            let minElement = createYieldIndicatorLabel(minYield, new Date(min.start).toLocaleString('default', { month: "short", day: "numeric", }) + ' - ' + roundToTons(extractYield(min)) + 't/ha');
                            colMin.appendChild(minElement)
                            row.appendChild(colMin)
                            /*
                            var colAvg = document.createElement('td');
                            let avgElement = createYieldIndicatorLabel(findYieldCass(extractYield(median), cropRanges), new Date(median.start).toLocaleString('default', { month: "short", day: "numeric", }) + ' - ' + roundToTons(extractYield(median)) + 't/ha');
                            colAvg.appendChild(avgElement)
                            row.appendChild(colAvg)
                            */

                            var colMax = document.createElement('td');
                            let maxYield = findYieldCass(extractYield(max), cropRanges);
                            let maxElement = createYieldIndicatorLabel(maxYield, new Date(max.start).toLocaleString('default', { month: "short", day: "numeric", }) + ' - ' + roundToTons(extractYield(max)) + 't/ha');
                            colMax.appendChild(maxElement)
                            row.appendChild(colMax)

                   
                            var colComment = document.createElement('td');
                            let commentElement = document.createElement('small');
                            if (minYield <= 1 && maxYield <= 1) {
                                commentElement.innerHTML =
                                   '@Localizer["unsuitable-date"]'+' '+cultivar.name
                            }
                            else if (minYield >= 3 && maxYield >= 3) {
                                commentElement.innerHTML =
                                    '@Localizer["suitable-date"]' + ' ' + cultivar.name
                            }

                            colComment.appendChild(commentElement)
                            row.appendChild(colComment)

                            table.appendChild(row)
                            i++;
                            results++;
                        }
                    })

                })

                if (results > 0) {
                    document.querySelector("#yieldContainers").appendChild(cropHeader)
                    document.querySelector("#yieldContainers").appendChild(cropLabels)
                    document.querySelector("#yieldContainers").appendChild(table)
                }

            });
        }
        function findYieldCass(value, ranges) {
            for (let [index, range] of ranges.entries()) {
                if (range.lower <= value && value < range.upper) {
                    return index;
                }
            }
            return 0;
        }


        function createYieldIndicatorLabel(idx, label) {
            let element = document.createElement('div');
            let className = 'not-found'
            let iconName = 'fa-face-sad-cry';
            switch (idx) {
                case 0:
                    className = 'yield-low';
                    iconName = 'fa-face-sad-cry';
                    break;
                case 1:
                    className = 'yield-regular';
                    iconName = 'fa-face-meh';
                    break;
                case 2:
                    className = 'yield-normal';
                    iconName = 'fa-face-smile';
                    break;
                case 3:
                    className = 'yield-good';
                    iconName = 'fa-face-grin-wide';
                    break;
                case 4:
                    className = 'yield-excellent';
                    iconName = 'fa-face-grin-stars';
                    break;

            }
            element.classList.add('yield-label', className)
            let icon = document.createElement('i')
            icon.classList.add('yield-icon', 'fa-solid', iconName);
            element.appendChild(icon)
            let labelEl = document.createElement('small')
            labelEl.innerHTML = label;
            element.appendChild(labelEl)
            return element;
        }


        function roundToTons(value) {
            return Number(value / 1000).toFixed(1)
        }
        function extractYield(value) {
            return value.data.find(d => d.measure.startsWith('yield')).avg
        }



        function createYieldDiagrams(agronomics, yieldForecast) {


            let sortedCrops = agronomics.sort((a, b) => {
                if (a.cp_Name < b.cp_Name) {
                    return -1;
                }
                if (a.cp_Name > b.cp_Name) {
                    return 1;
                }
                return 0;
            })


            sortedCrops.forEach(crop => {

                var cropRanges = weatherStation.ranges.filter(r => r.crop_Id == crop.cp_Id);
                cropRanges.sort((a, b) => a.lower - b.lower)
               // console.log('cropRanges', cropRanges)

                var cropContainer = document.createElement('div');
                document.querySelector("#yieldContainers").appendChild(cropContainer)


                var cropHeader = document.createElement('h2');
                cropHeader.classList.add('crop-heading')
                cropHeader.innerHTML = crop.cp_Name;



                crop.cultivars.forEach((cultivar,idx) => {
                    if (yieldForecast.yield.length == 0) return;
                    let filteredYieldsForCultivar = yieldForecast.yield[0].yield.filter(yieldData => yieldData.cultivar == cultivar.id)
                    let series = [];
                    let soilWithData = {};
                    cropRanges.forEach(range => {

                        let yieldData = [];

                        crop.soils.forEach(soil => {

                            let filteredYieldsForSoil = filteredYieldsForCultivar.filter(yieldData => yieldData.soil == soil.id);
                            let filteredYieldForRange = filteredYieldsForSoil.filter(yieldData => {
                                let mYield = extractYield(yieldData);
                                return range.lower < mYield && mYield < range.upper;
                            })


                            //console.log('filteredYieldForRange', range, soil, filteredYieldForRange)
                            let dates = filteredYieldForRange.map(yieldData => new Date(yieldData.start)).sort((a, b) => a - b)
                            if (dates.length > 0) {
                                yieldData.push({
                                    x: soil.name,
                                    y: [
                                        dates[0].getTime(),
                                        dates[dates.length - 1].getTime()
                                    ]
                                })
                                soilWithData[soil.id] = true;
                            }
                        });


                        series.push({
                            name: range.label + ' (' + roundToTons(range.lower) + ' - ' + roundToTons(range.upper) + 't/ha)',
                            data: yieldData
                        })
                    })
                  //  console.log('series', soilWithData, series)
                    if (series.length == 0) return;


                    var options = {
                        series: series,

                        chart: {
                            height: Object.keys(soilWithData).length * 70 + 'px',
                            type: 'rangeBar',
                            toolbar: {
                                show: false
                            },
                            zoom: {
                                enabled: false,
                            },


                        },
                        plotOptions: {
                            bar: {
                                horizontal: true,
                                rangeBarGroupRows: true,
                                //   barHeight: '20px',
                            }
                        },
                        colors: [
                            "#e33327", "#e37f27", "#c7e327", "#82e327", "#15eb31",

                        ],
                        xaxis: {
                            type: 'datetime',
                            labels: {
                                style: {
                                    fontSize: '14px',
                                    fontWeight: 600,
                                },
                            },
                        },
                        yaxis: {
                            labels: {
                                style: {
                                    fontSize: '14px',
                                    fontWeight: 600,
                                },
                            },
                        },
                        legend: {
                           /* fontSize: '14px',
                            fontWeight: 600,
                            markers: {
                                width: 20,
                                height: 20,
                            },*/
                            position: 'top',
                            horizontalAlign: 'center',
                        },
                        title: {
                            text: cultivar.name,
                            style: {
                                fontSize: '18px',

                            },
                        },
                    };
                    if (idx == 0) {
                        cropContainer.appendChild(cropHeader);
                    }
                    var element = document.createElement('div');
                    element.classList.add('yield-chart');
                    element.classList.add('printable-chart');
                    cropContainer.appendChild(element)
                    var chart = new ApexCharts(element, options);
                    chart.render();

                });


            });
        }



        async function savePdf() {
           window.print();

        }
        window.loading_screen.finish();
    </script>
}
